// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using DndSpellsJson;
//
//    var the5ESpells = The5ESpells.FromJson(jsonString);

namespace DndSpellsJson
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class The5ESpells
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("desc")]
        public List<string> Desc { get; set; }

        [JsonProperty("higher_level", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> HigherLevel { get; set; }

        [JsonProperty("page")]
        public string Page { get; set; }

        [JsonProperty("range")]
        public Range Range { get; set; }

        [JsonProperty("components")]
        public List<Component> Components { get; set; }

        [JsonProperty("material", NullValueHandling = NullValueHandling.Ignore)]
        public string Material { get; set; }

        [JsonProperty("ritual")]
        public bool Ritual { get; set; }

        [JsonProperty("duration")]
        public string Duration { get; set; }

        [JsonProperty("concentration")]
        public bool Concentration { get; set; }

        [JsonProperty("casting_time")]
        public CastingTime CastingTime { get; set; }

        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("school")]
        public School School { get; set; }

        [JsonProperty("classes")]
        public List<School> Classes { get; set; }

        [JsonProperty("subclasses")]
        public List<School> Subclasses { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public partial class School
    {
        [JsonProperty("name")]
        public Name Name { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public enum CastingTime { The10Minutes, The12Hours, The1Action, The1BonusAction, The1Hour, The1Minute, The1Reaction, The24Hours, The8Hours };

    public enum Name { Abjuration, Bard, Cleric, Conjuration, Devotion, Divination, Druid, Enchantment, Evocation, Fiend, Illusion, Land, Life, Lore, Necromancy, Paladin, Ranger, Sorcerer, Transmutation, Warlock, Wizard };

    public enum Component { M, S, V };

    public enum Range { Self, Sight, Special, The100Feet, The10Feet, The120Feet, The150Feet, The1Mile, The300Feet, The30Feet, The500Feet, The500Miles, The5Feet, The60Feet, The90Feet, Touch, Unlimited };

    public partial class The5ESpells
    {
        public static List<The5ESpells> FromJson(string json) => JsonConvert.DeserializeObject<List<The5ESpells>>(json, DndSpellsJson.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<The5ESpells> self) => JsonConvert.SerializeObject(self, DndSpellsJson.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CastingTimeConverter.Singleton,
                NameConverter.Singleton,
                ComponentConverter.Singleton,
                RangeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CastingTimeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CastingTime) || t == typeof(CastingTime?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "1 action":
                    return CastingTime.The1Action;
                case "1 bonus action":
                    return CastingTime.The1BonusAction;
                case "1 hour":
                    return CastingTime.The1Hour;
                case "1 minute":
                    return CastingTime.The1Minute;
                case "1 reaction":
                    return CastingTime.The1Reaction;
                case "10 minutes":
                    return CastingTime.The10Minutes;
                case "12 hours":
                    return CastingTime.The12Hours;
                case "24 hours":
                    return CastingTime.The24Hours;
                case "8 hours":
                    return CastingTime.The8Hours;
            }
            throw new Exception("Cannot unmarshal type CastingTime");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CastingTime)untypedValue;
            switch (value)
            {
                case CastingTime.The1Action:
                    serializer.Serialize(writer, "1 action");
                    return;
                case CastingTime.The1BonusAction:
                    serializer.Serialize(writer, "1 bonus action");
                    return;
                case CastingTime.The1Hour:
                    serializer.Serialize(writer, "1 hour");
                    return;
                case CastingTime.The1Minute:
                    serializer.Serialize(writer, "1 minute");
                    return;
                case CastingTime.The1Reaction:
                    serializer.Serialize(writer, "1 reaction");
                    return;
                case CastingTime.The10Minutes:
                    serializer.Serialize(writer, "10 minutes");
                    return;
                case CastingTime.The12Hours:
                    serializer.Serialize(writer, "12 hours");
                    return;
                case CastingTime.The24Hours:
                    serializer.Serialize(writer, "24 hours");
                    return;
                case CastingTime.The8Hours:
                    serializer.Serialize(writer, "8 hours");
                    return;
            }
            throw new Exception("Cannot marshal type CastingTime");
        }

        public static readonly CastingTimeConverter Singleton = new CastingTimeConverter();
    }

    internal class NameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Name) || t == typeof(Name?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Abjuration":
                    return Name.Abjuration;
                case "Bard":
                    return Name.Bard;
                case "Cleric":
                    return Name.Cleric;
                case "Conjuration":
                    return Name.Conjuration;
                case "Devotion":
                    return Name.Devotion;
                case "Divination":
                    return Name.Divination;
                case "Druid":
                    return Name.Druid;
                case "Enchantment":
                    return Name.Enchantment;
                case "Evocation":
                    return Name.Evocation;
                case "Fiend":
                    return Name.Fiend;
                case "Illusion":
                    return Name.Illusion;
                case "Land":
                    return Name.Land;
                case "Life":
                    return Name.Life;
                case "Lore":
                    return Name.Lore;
                case "Necromancy":
                    return Name.Necromancy;
                case "Paladin":
                    return Name.Paladin;
                case "Ranger":
                    return Name.Ranger;
                case "Sorcerer":
                    return Name.Sorcerer;
                case "Transmutation":
                    return Name.Transmutation;
                case "Warlock":
                    return Name.Warlock;
                case "Wizard":
                    return Name.Wizard;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Name)untypedValue;
            switch (value)
            {
                case Name.Abjuration:
                    serializer.Serialize(writer, "Abjuration");
                    return;
                case Name.Bard:
                    serializer.Serialize(writer, "Bard");
                    return;
                case Name.Cleric:
                    serializer.Serialize(writer, "Cleric");
                    return;
                case Name.Conjuration:
                    serializer.Serialize(writer, "Conjuration");
                    return;
                case Name.Devotion:
                    serializer.Serialize(writer, "Devotion");
                    return;
                case Name.Divination:
                    serializer.Serialize(writer, "Divination");
                    return;
                case Name.Druid:
                    serializer.Serialize(writer, "Druid");
                    return;
                case Name.Enchantment:
                    serializer.Serialize(writer, "Enchantment");
                    return;
                case Name.Evocation:
                    serializer.Serialize(writer, "Evocation");
                    return;
                case Name.Fiend:
                    serializer.Serialize(writer, "Fiend");
                    return;
                case Name.Illusion:
                    serializer.Serialize(writer, "Illusion");
                    return;
                case Name.Land:
                    serializer.Serialize(writer, "Land");
                    return;
                case Name.Life:
                    serializer.Serialize(writer, "Life");
                    return;
                case Name.Lore:
                    serializer.Serialize(writer, "Lore");
                    return;
                case Name.Necromancy:
                    serializer.Serialize(writer, "Necromancy");
                    return;
                case Name.Paladin:
                    serializer.Serialize(writer, "Paladin");
                    return;
                case Name.Ranger:
                    serializer.Serialize(writer, "Ranger");
                    return;
                case Name.Sorcerer:
                    serializer.Serialize(writer, "Sorcerer");
                    return;
                case Name.Transmutation:
                    serializer.Serialize(writer, "Transmutation");
                    return;
                case Name.Warlock:
                    serializer.Serialize(writer, "Warlock");
                    return;
                case Name.Wizard:
                    serializer.Serialize(writer, "Wizard");
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class ComponentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Component) || t == typeof(Component?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "M":
                    return Component.M;
                case "S":
                    return Component.S;
                case "V":
                    return Component.V;
            }
            throw new Exception("Cannot unmarshal type Component");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Component)untypedValue;
            switch (value)
            {
                case Component.M:
                    serializer.Serialize(writer, "M");
                    return;
                case Component.S:
                    serializer.Serialize(writer, "S");
                    return;
                case Component.V:
                    serializer.Serialize(writer, "V");
                    return;
            }
            throw new Exception("Cannot marshal type Component");
        }

        public static readonly ComponentConverter Singleton = new ComponentConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class RangeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Range) || t == typeof(Range?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "1 mile":
                    return Range.The1Mile;
                case "10 feet":
                    return Range.The10Feet;
                case "100 feet":
                    return Range.The100Feet;
                case "120 feet":
                    return Range.The120Feet;
                case "150 feet":
                    return Range.The150Feet;
                case "30 feet":
                    return Range.The30Feet;
                case "300 feet":
                    return Range.The300Feet;
                case "5 feet":
                    return Range.The5Feet;
                case "500 feet":
                    return Range.The500Feet;
                case "500 miles":
                    return Range.The500Miles;
                case "60 feet":
                    return Range.The60Feet;
                case "90 feet":
                    return Range.The90Feet;
                case "Self":
                    return Range.Self;
                case "Sight":
                    return Range.Sight;
                case "Special":
                    return Range.Special;
                case "Touch":
                    return Range.Touch;
                case "Unlimited":
                    return Range.Unlimited;
            }
            throw new Exception("Cannot unmarshal type Range");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Range)untypedValue;
            switch (value)
            {
                case Range.The1Mile:
                    serializer.Serialize(writer, "1 mile");
                    return;
                case Range.The10Feet:
                    serializer.Serialize(writer, "10 feet");
                    return;
                case Range.The100Feet:
                    serializer.Serialize(writer, "100 feet");
                    return;
                case Range.The120Feet:
                    serializer.Serialize(writer, "120 feet");
                    return;
                case Range.The150Feet:
                    serializer.Serialize(writer, "150 feet");
                    return;
                case Range.The30Feet:
                    serializer.Serialize(writer, "30 feet");
                    return;
                case Range.The300Feet:
                    serializer.Serialize(writer, "300 feet");
                    return;
                case Range.The5Feet:
                    serializer.Serialize(writer, "5 feet");
                    return;
                case Range.The500Feet:
                    serializer.Serialize(writer, "500 feet");
                    return;
                case Range.The500Miles:
                    serializer.Serialize(writer, "500 miles");
                    return;
                case Range.The60Feet:
                    serializer.Serialize(writer, "60 feet");
                    return;
                case Range.The90Feet:
                    serializer.Serialize(writer, "90 feet");
                    return;
                case Range.Self:
                    serializer.Serialize(writer, "Self");
                    return;
                case Range.Sight:
                    serializer.Serialize(writer, "Sight");
                    return;
                case Range.Special:
                    serializer.Serialize(writer, "Special");
                    return;
                case Range.Touch:
                    serializer.Serialize(writer, "Touch");
                    return;
                case Range.Unlimited:
                    serializer.Serialize(writer, "Unlimited");
                    return;
            }
            throw new Exception("Cannot marshal type Range");
        }

        public static readonly RangeConverter Singleton = new RangeConverter();
    }
}
