// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using DndMonstersJson;
//
//    var the5EMonsters = The5EMonsters.FromJson(jsonString);

namespace DndMonstersJson
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class The5EMonsters
    {
        [JsonProperty("id")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("size")]
        public Size Size { get; set; }

        [JsonProperty("type")]
        public TypeEnum Type { get; set; }

        [JsonProperty("subtype")]
        public string Subtype { get; set; }

        [JsonProperty("alignment")]
        public Alignment Alignment { get; set; }

        [JsonProperty("armor_class")]
        public long ArmorClass { get; set; }

        [JsonProperty("hit_points")]
        public long HitPoints { get; set; }

        [JsonProperty("hit_dice")]
        public string HitDice { get; set; }

        [JsonProperty("speed")]
        public The5EMonsterSpeed Speed { get; set; }

        [JsonProperty("strength")]
        public long Strength { get; set; }

        [JsonProperty("dexterity")]
        public long Dexterity { get; set; }

        [JsonProperty("constitution")]
        public long Constitution { get; set; }

        [JsonProperty("intelligence")]
        public long Intelligence { get; set; }

        [JsonProperty("wisdom")]
        public long Wisdom { get; set; }

        [JsonProperty("charisma")]
        public long Charisma { get; set; }

        [JsonProperty("proficiencies")]
        public List<Proficiency> Proficiencies { get; set; }

        [JsonProperty("damage_vulnerabilities")]
        public List<string> DamageVulnerabilities { get; set; }

        [JsonProperty("damage_resistances")]
        public List<string> DamageResistances { get; set; }

        [JsonProperty("damage_immunities")]
        public List<string> DamageImmunities { get; set; }

        [JsonProperty("condition_immunities")]
        public List<ConditionImmunity> ConditionImmunities { get; set; }

        [JsonProperty("senses")]
        public Senses Senses { get; set; }

        [JsonProperty("languages")]
        public string Languages { get; set; }

        [JsonProperty("challenge_rating")]
        public double ChallengeRating { get; set; }

        [JsonProperty("special_abilities", NullValueHandling = NullValueHandling.Ignore)]
        public List<LegendaryAction> SpecialAbilities { get; set; }

        [JsonProperty("actions", NullValueHandling = NullValueHandling.Ignore)]
        public List<Action> Actions { get; set; }

        [JsonProperty("legendary_actions", NullValueHandling = NullValueHandling.Ignore)]
        public List<LegendaryAction> LegendaryActions { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }

        [JsonProperty("reactions", NullValueHandling = NullValueHandling.Ignore)]
        public List<LegendaryAction> Reactions { get; set; }

        [JsonProperty("other_speeds", NullValueHandling = NullValueHandling.Ignore)]
        public List<OtherSpeed> OtherSpeeds { get; set; }
    }

    public partial class Action
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("desc")]
        public string Desc { get; set; }

        [JsonProperty("attack_bonus", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttackBonus { get; set; }

        [JsonProperty("dc", NullValueHandling = NullValueHandling.Ignore)]
        public Dc Dc { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public DamageUnion? Damage { get; set; }

        [JsonProperty("attacks", NullValueHandling = NullValueHandling.Ignore)]
        public List<Attack> Attacks { get; set; }

        [JsonProperty("damage_dice", NullValueHandling = NullValueHandling.Ignore)]
        public string DamageDice { get; set; }
    }

    public partial class Attack
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("dc")]
        public Dc Dc { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public List<FromElement> Damage { get; set; }
    }

    public partial class FromElement
    {
        [JsonProperty("damage_type")]
        public ConditionImmunity DamageType { get; set; }

        [JsonProperty("damage_dice")]
        public string DamageDice { get; set; }

        [JsonProperty("damage_bonus")]
        public long DamageBonus { get; set; }
    }

    public partial class ConditionImmunity
    {
        [JsonProperty("name")]
        public ConditionImmunityName Name { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public partial class Dc
    {
        [JsonProperty("dc_type")]
        public ConditionImmunity DcType { get; set; }

        [JsonProperty("dc_value")]
        public long DcValue { get; set; }

        [JsonProperty("success_type")]
        public SuccessType SuccessType { get; set; }
    }

    public partial class PurpleDamage
    {
        [JsonProperty("damage_type", NullValueHandling = NullValueHandling.Ignore)]
        public ConditionImmunity DamageType { get; set; }

        [JsonProperty("damage_dice", NullValueHandling = NullValueHandling.Ignore)]
        public string DamageDice { get; set; }

        [JsonProperty("damage_bonus", NullValueHandling = NullValueHandling.Ignore)]
        public long? DamageBonus { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }

        [JsonProperty("dice", NullValueHandling = NullValueHandling.Ignore)]
        public string Dice { get; set; }

        [JsonProperty("bonus", NullValueHandling = NullValueHandling.Ignore)]
        public long? Bonus { get; set; }

        [JsonProperty("dc", NullValueHandling = NullValueHandling.Ignore)]
        public Dc Dc { get; set; }

        [JsonProperty("choose", NullValueHandling = NullValueHandling.Ignore)]
        public long? Choose { get; set; }

        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public List<FromElement> From { get; set; }
    }

    public partial class LegendaryAction
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("desc")]
        public string Desc { get; set; }

        [JsonProperty("attack_bonus", NullValueHandling = NullValueHandling.Ignore)]
        public long? AttackBonus { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public List<FromElement> Damage { get; set; }

        [JsonProperty("dc", NullValueHandling = NullValueHandling.Ignore)]
        public Dc Dc { get; set; }
    }

    public partial class OtherSpeed
    {
        [JsonProperty("form")]
        public string Form { get; set; }

        [JsonProperty("speed")]
        public OtherSpeedSpeed Speed { get; set; }
    }

    public partial class OtherSpeedSpeed
    {
        [JsonProperty("walk")]
        public Darkvision Walk { get; set; }

        [JsonProperty("climb", NullValueHandling = NullValueHandling.Ignore)]
        public Blindsight? Climb { get; set; }
    }

    public partial class Proficiency
    {
        [JsonProperty("name")]
        public ProficiencyName Name { get; set; }

        [JsonProperty("ref")]
        public Ref Ref { get; set; }

        [JsonProperty("value")]
        public long Value { get; set; }
    }

    public partial class Senses
    {
        [JsonProperty("darkvision", NullValueHandling = NullValueHandling.Ignore)]
        public Darkvision? Darkvision { get; set; }

        [JsonProperty("passive_perception")]
        public long PassivePerception { get; set; }

        [JsonProperty("blindsight", NullValueHandling = NullValueHandling.Ignore)]
        public Blindsight? Blindsight { get; set; }

        [JsonProperty("truesight", NullValueHandling = NullValueHandling.Ignore)]
        public Blindsight? Truesight { get; set; }

        [JsonProperty("tremorsense", NullValueHandling = NullValueHandling.Ignore)]
        public Blindsight? Tremorsense { get; set; }
    }

    public partial class The5EMonsterSpeed
    {
        [JsonProperty("walk", NullValueHandling = NullValueHandling.Ignore)]
        public Burrow? Walk { get; set; }

        [JsonProperty("swim", NullValueHandling = NullValueHandling.Ignore)]
        public Burrow? Swim { get; set; }

        [JsonProperty("fly", NullValueHandling = NullValueHandling.Ignore)]
        public Darkvision? Fly { get; set; }

        [JsonProperty("burrow", NullValueHandling = NullValueHandling.Ignore)]
        public Burrow? Burrow { get; set; }

        [JsonProperty("climb", NullValueHandling = NullValueHandling.Ignore)]
        public Burrow? Climb { get; set; }

        [JsonProperty("hover", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hover { get; set; }
    }

    public enum ConditionImmunityName { Acid, Blinded, Bludgeoning, Cha, Charmed, Cold, Con, Dex, Exhaustion, Fire, Frightened, Grappled, Lightning, Necrotic, Paralyzed, Petrified, Piercing, Poison, Poisoned, Prone, Psychic, Radiant, Restrained, Slashing, Str, Stunned, Thunder, Unconscious, Wis };

    public enum SuccessType { Hafl, Half, Nhalfone, None };

    public enum Alignment { AnyAlignment, AnyChaoticAlignment, AnyEvilAlignment, AnyNonGoodAlignment, AnyNonLawfulAlignment, ChaoticEvil, ChaoticGood, ChaoticNeutral, LawfulEvil, LawfulGood, LawfulNeutral, Neutral, NeutralEvil, NeutralGood, NeutralGood50OrNeutralEvil50, Unaligned };

    public enum Blindsight { The10Ft, The120Ft, The30Ft, The30FtBlindBeyondThisRadius, The30FtOr10FtWhileDeafenedBlindBeyondThisRadius, The60Ft, The60FtBlindBeyondThisRadius };

    public enum Darkvision { The120Ft, The150Ft, The30Ft, The40Ft, The50Ft, The60Ft, The60FtRatFormOnly, The80Ft, The90Ft };

    public enum ProficiencyName { SavingThrowCha, SavingThrowCon, SavingThrowDex, SavingThrowInt, SavingThrowStr, SavingThrowWis, SkillAcrobatics, SkillArcana, SkillAthletics, SkillDeception, SkillHistory, SkillInsight, SkillIntimidation, SkillInvestigation, SkillMedicine, SkillNature, SkillPerception, SkillPerformance, SkillPersuasion, SkillReligion, SkillStealth, SkillSurvival };

    public enum Ref { Proficiencies100, Proficiencies101, Proficiencies102, Proficiencies103, Proficiencies104, Proficiencies105, Proficiencies107, Proficiencies108, Proficiencies109, Proficiencies110, Proficiencies111, Proficiencies112, Proficiencies113, Proficiencies114, Proficiencies115, Proficiencies116, Proficiencies117, Proficiencies118, Proficiencies119, Proficiencies121, Proficiencies122, Proficiencies99 };

    public enum Size { Gargantuan, Huge, Large, Medium, Small, Tiny };

    public enum Burrow { The0Ft, The10Ft, The15Ft, The20Ft, The25Ft, The30Ft, The40Ft, The50Ft, The5Ft, The60Ft, The90Ft };

    public enum TypeEnum { Aberration, Beast, Celestial, Construct, Dragon, Elemental, Fey, Fiend, Giant, Humanoid, Monstrosity, Ooze, Plant, SwarmOfTinyBeasts, Undead };

    public partial struct DamageUnion
    {
        public FromElement FromElement;
        public List<PurpleDamage> PurpleDamageArray;

        public static implicit operator DamageUnion(FromElement FromElement) => new DamageUnion { FromElement = FromElement };
        public static implicit operator DamageUnion(List<PurpleDamage> PurpleDamageArray) => new DamageUnion { PurpleDamageArray = PurpleDamageArray };
    }

    public partial class The5EMonsters
    {
        public static List<The5EMonsters> FromJson(string json) => JsonConvert.DeserializeObject<List<The5EMonsters>>(json, DndMonstersJson.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this List<The5EMonsters> self) => JsonConvert.SerializeObject(self, DndMonstersJson.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ConditionImmunityNameConverter.Singleton,
                SuccessTypeConverter.Singleton,
                DamageUnionConverter.Singleton,
                AlignmentConverter.Singleton,
                BlindsightConverter.Singleton,
                DarkvisionConverter.Singleton,
                ProficiencyNameConverter.Singleton,
                RefConverter.Singleton,
                SizeConverter.Singleton,
                BurrowConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ConditionImmunityNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConditionImmunityName) || t == typeof(ConditionImmunityName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Acid":
                    return ConditionImmunityName.Acid;
                case "Blinded":
                    return ConditionImmunityName.Blinded;
                case "Bludgeoning":
                    return ConditionImmunityName.Bludgeoning;
                case "CHA":
                    return ConditionImmunityName.Cha;
                case "CON":
                    return ConditionImmunityName.Con;
                case "Charmed":
                    return ConditionImmunityName.Charmed;
                case "Cold":
                    return ConditionImmunityName.Cold;
                case "DEX":
                    return ConditionImmunityName.Dex;
                case "Exhaustion":
                    return ConditionImmunityName.Exhaustion;
                case "Fire":
                    return ConditionImmunityName.Fire;
                case "Frightened":
                    return ConditionImmunityName.Frightened;
                case "Grappled":
                    return ConditionImmunityName.Grappled;
                case "Lightning":
                    return ConditionImmunityName.Lightning;
                case "Necrotic":
                    return ConditionImmunityName.Necrotic;
                case "Paralyzed":
                    return ConditionImmunityName.Paralyzed;
                case "Petrified":
                    return ConditionImmunityName.Petrified;
                case "Piercing":
                    return ConditionImmunityName.Piercing;
                case "Poison":
                    return ConditionImmunityName.Poison;
                case "Poisoned":
                    return ConditionImmunityName.Poisoned;
                case "Prone":
                    return ConditionImmunityName.Prone;
                case "Psychic":
                    return ConditionImmunityName.Psychic;
                case "Radiant":
                    return ConditionImmunityName.Radiant;
                case "Restrained":
                    return ConditionImmunityName.Restrained;
                case "STR":
                    return ConditionImmunityName.Str;
                case "Slashing":
                    return ConditionImmunityName.Slashing;
                case "Stunned":
                    return ConditionImmunityName.Stunned;
                case "Thunder":
                    return ConditionImmunityName.Thunder;
                case "Unconscious":
                    return ConditionImmunityName.Unconscious;
                case "WIS":
                    return ConditionImmunityName.Wis;
            }
            throw new Exception("Cannot unmarshal type ConditionImmunityName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConditionImmunityName)untypedValue;
            switch (value)
            {
                case ConditionImmunityName.Acid:
                    serializer.Serialize(writer, "Acid");
                    return;
                case ConditionImmunityName.Blinded:
                    serializer.Serialize(writer, "Blinded");
                    return;
                case ConditionImmunityName.Bludgeoning:
                    serializer.Serialize(writer, "Bludgeoning");
                    return;
                case ConditionImmunityName.Cha:
                    serializer.Serialize(writer, "CHA");
                    return;
                case ConditionImmunityName.Con:
                    serializer.Serialize(writer, "CON");
                    return;
                case ConditionImmunityName.Charmed:
                    serializer.Serialize(writer, "Charmed");
                    return;
                case ConditionImmunityName.Cold:
                    serializer.Serialize(writer, "Cold");
                    return;
                case ConditionImmunityName.Dex:
                    serializer.Serialize(writer, "DEX");
                    return;
                case ConditionImmunityName.Exhaustion:
                    serializer.Serialize(writer, "Exhaustion");
                    return;
                case ConditionImmunityName.Fire:
                    serializer.Serialize(writer, "Fire");
                    return;
                case ConditionImmunityName.Frightened:
                    serializer.Serialize(writer, "Frightened");
                    return;
                case ConditionImmunityName.Grappled:
                    serializer.Serialize(writer, "Grappled");
                    return;
                case ConditionImmunityName.Lightning:
                    serializer.Serialize(writer, "Lightning");
                    return;
                case ConditionImmunityName.Necrotic:
                    serializer.Serialize(writer, "Necrotic");
                    return;
                case ConditionImmunityName.Paralyzed:
                    serializer.Serialize(writer, "Paralyzed");
                    return;
                case ConditionImmunityName.Petrified:
                    serializer.Serialize(writer, "Petrified");
                    return;
                case ConditionImmunityName.Piercing:
                    serializer.Serialize(writer, "Piercing");
                    return;
                case ConditionImmunityName.Poison:
                    serializer.Serialize(writer, "Poison");
                    return;
                case ConditionImmunityName.Poisoned:
                    serializer.Serialize(writer, "Poisoned");
                    return;
                case ConditionImmunityName.Prone:
                    serializer.Serialize(writer, "Prone");
                    return;
                case ConditionImmunityName.Psychic:
                    serializer.Serialize(writer, "Psychic");
                    return;
                case ConditionImmunityName.Radiant:
                    serializer.Serialize(writer, "Radiant");
                    return;
                case ConditionImmunityName.Restrained:
                    serializer.Serialize(writer, "Restrained");
                    return;
                case ConditionImmunityName.Str:
                    serializer.Serialize(writer, "STR");
                    return;
                case ConditionImmunityName.Slashing:
                    serializer.Serialize(writer, "Slashing");
                    return;
                case ConditionImmunityName.Stunned:
                    serializer.Serialize(writer, "Stunned");
                    return;
                case ConditionImmunityName.Thunder:
                    serializer.Serialize(writer, "Thunder");
                    return;
                case ConditionImmunityName.Unconscious:
                    serializer.Serialize(writer, "Unconscious");
                    return;
                case ConditionImmunityName.Wis:
                    serializer.Serialize(writer, "WIS");
                    return;
            }
            throw new Exception("Cannot marshal type ConditionImmunityName");
        }

        public static readonly ConditionImmunityNameConverter Singleton = new ConditionImmunityNameConverter();
    }

    internal class SuccessTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SuccessType) || t == typeof(SuccessType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hafl":
                    return SuccessType.Hafl;
                case "half":
                    return SuccessType.Half;
                case "nhalfone":
                    return SuccessType.Nhalfone;
                case "none":
                    return SuccessType.None;
            }
            throw new Exception("Cannot unmarshal type SuccessType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SuccessType)untypedValue;
            switch (value)
            {
                case SuccessType.Hafl:
                    serializer.Serialize(writer, "hafl");
                    return;
                case SuccessType.Half:
                    serializer.Serialize(writer, "half");
                    return;
                case SuccessType.Nhalfone:
                    serializer.Serialize(writer, "nhalfone");
                    return;
                case SuccessType.None:
                    serializer.Serialize(writer, "none");
                    return;
            }
            throw new Exception("Cannot marshal type SuccessType");
        }

        public static readonly SuccessTypeConverter Singleton = new SuccessTypeConverter();
    }

    internal class DamageUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DamageUnion) || t == typeof(DamageUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<FromElement>(reader);
                    return new DamageUnion { FromElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<PurpleDamage>>(reader);
                    return new DamageUnion { PurpleDamageArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DamageUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DamageUnion)untypedValue;
            if (value.PurpleDamageArray != null)
            {
                serializer.Serialize(writer, value.PurpleDamageArray);
                return;
            }
            if (value.FromElement != null)
            {
                serializer.Serialize(writer, value.FromElement);
                return;
            }
            throw new Exception("Cannot marshal type DamageUnion");
        }

        public static readonly DamageUnionConverter Singleton = new DamageUnionConverter();
    }

    internal class AlignmentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Alignment) || t == typeof(Alignment?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "any alignment":
                    return Alignment.AnyAlignment;
                case "any chaotic alignment":
                    return Alignment.AnyChaoticAlignment;
                case "any evil alignment":
                    return Alignment.AnyEvilAlignment;
                case "any non-good alignment":
                    return Alignment.AnyNonGoodAlignment;
                case "any non-lawful alignment":
                    return Alignment.AnyNonLawfulAlignment;
                case "chaotic evil":
                    return Alignment.ChaoticEvil;
                case "chaotic good":
                    return Alignment.ChaoticGood;
                case "chaotic neutral":
                    return Alignment.ChaoticNeutral;
                case "lawful evil":
                    return Alignment.LawfulEvil;
                case "lawful good":
                    return Alignment.LawfulGood;
                case "lawful neutral":
                    return Alignment.LawfulNeutral;
                case "neutral":
                    return Alignment.Neutral;
                case "neutral evil":
                    return Alignment.NeutralEvil;
                case "neutral good":
                    return Alignment.NeutralGood;
                case "neutral good (50%) or neutral evil (50%)":
                    return Alignment.NeutralGood50OrNeutralEvil50;
                case "unaligned":
                    return Alignment.Unaligned;
            }
            throw new Exception("Cannot unmarshal type Alignment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Alignment)untypedValue;
            switch (value)
            {
                case Alignment.AnyAlignment:
                    serializer.Serialize(writer, "any alignment");
                    return;
                case Alignment.AnyChaoticAlignment:
                    serializer.Serialize(writer, "any chaotic alignment");
                    return;
                case Alignment.AnyEvilAlignment:
                    serializer.Serialize(writer, "any evil alignment");
                    return;
                case Alignment.AnyNonGoodAlignment:
                    serializer.Serialize(writer, "any non-good alignment");
                    return;
                case Alignment.AnyNonLawfulAlignment:
                    serializer.Serialize(writer, "any non-lawful alignment");
                    return;
                case Alignment.ChaoticEvil:
                    serializer.Serialize(writer, "chaotic evil");
                    return;
                case Alignment.ChaoticGood:
                    serializer.Serialize(writer, "chaotic good");
                    return;
                case Alignment.ChaoticNeutral:
                    serializer.Serialize(writer, "chaotic neutral");
                    return;
                case Alignment.LawfulEvil:
                    serializer.Serialize(writer, "lawful evil");
                    return;
                case Alignment.LawfulGood:
                    serializer.Serialize(writer, "lawful good");
                    return;
                case Alignment.LawfulNeutral:
                    serializer.Serialize(writer, "lawful neutral");
                    return;
                case Alignment.Neutral:
                    serializer.Serialize(writer, "neutral");
                    return;
                case Alignment.NeutralEvil:
                    serializer.Serialize(writer, "neutral evil");
                    return;
                case Alignment.NeutralGood:
                    serializer.Serialize(writer, "neutral good");
                    return;
                case Alignment.NeutralGood50OrNeutralEvil50:
                    serializer.Serialize(writer, "neutral good (50%) or neutral evil (50%)");
                    return;
                case Alignment.Unaligned:
                    serializer.Serialize(writer, "unaligned");
                    return;
            }
            throw new Exception("Cannot marshal type Alignment");
        }

        public static readonly AlignmentConverter Singleton = new AlignmentConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class BlindsightConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Blindsight) || t == typeof(Blindsight?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "10 ft.":
                    return Blindsight.The10Ft;
                case "120 ft.":
                    return Blindsight.The120Ft;
                case "30 ft.":
                    return Blindsight.The30Ft;
                case "30 ft. (blind beyond this radius)":
                    return Blindsight.The30FtBlindBeyondThisRadius;
                case "30 ft. or 10 ft. while deafened (blind beyond this radius)":
                    return Blindsight.The30FtOr10FtWhileDeafenedBlindBeyondThisRadius;
                case "60 ft.":
                    return Blindsight.The60Ft;
                case "60 ft. (blind beyond this radius)":
                    return Blindsight.The60FtBlindBeyondThisRadius;
            }
            throw new Exception("Cannot unmarshal type Blindsight");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Blindsight)untypedValue;
            switch (value)
            {
                case Blindsight.The10Ft:
                    serializer.Serialize(writer, "10 ft.");
                    return;
                case Blindsight.The120Ft:
                    serializer.Serialize(writer, "120 ft.");
                    return;
                case Blindsight.The30Ft:
                    serializer.Serialize(writer, "30 ft.");
                    return;
                case Blindsight.The30FtBlindBeyondThisRadius:
                    serializer.Serialize(writer, "30 ft. (blind beyond this radius)");
                    return;
                case Blindsight.The30FtOr10FtWhileDeafenedBlindBeyondThisRadius:
                    serializer.Serialize(writer, "30 ft. or 10 ft. while deafened (blind beyond this radius)");
                    return;
                case Blindsight.The60Ft:
                    serializer.Serialize(writer, "60 ft.");
                    return;
                case Blindsight.The60FtBlindBeyondThisRadius:
                    serializer.Serialize(writer, "60 ft. (blind beyond this radius)");
                    return;
            }
            throw new Exception("Cannot marshal type Blindsight");
        }

        public static readonly BlindsightConverter Singleton = new BlindsightConverter();
    }

    internal class DarkvisionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Darkvision) || t == typeof(Darkvision?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "120 ft.":
                    return Darkvision.The120Ft;
                case "150 ft.":
                    return Darkvision.The150Ft;
                case "30 ft.":
                    return Darkvision.The30Ft;
                case "40 ft.":
                    return Darkvision.The40Ft;
                case "50 ft.":
                    return Darkvision.The50Ft;
                case "60 ft.":
                    return Darkvision.The60Ft;
                case "60 ft. (rat form only)":
                    return Darkvision.The60FtRatFormOnly;
                case "80 ft.":
                    return Darkvision.The80Ft;
                case "90 ft.":
                    return Darkvision.The90Ft;
            }
            throw new Exception("Cannot unmarshal type Darkvision");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Darkvision)untypedValue;
            switch (value)
            {
                case Darkvision.The120Ft:
                    serializer.Serialize(writer, "120 ft.");
                    return;
                case Darkvision.The150Ft:
                    serializer.Serialize(writer, "150 ft.");
                    return;
                case Darkvision.The30Ft:
                    serializer.Serialize(writer, "30 ft.");
                    return;
                case Darkvision.The40Ft:
                    serializer.Serialize(writer, "40 ft.");
                    return;
                case Darkvision.The50Ft:
                    serializer.Serialize(writer, "50 ft.");
                    return;
                case Darkvision.The60Ft:
                    serializer.Serialize(writer, "60 ft.");
                    return;
                case Darkvision.The60FtRatFormOnly:
                    serializer.Serialize(writer, "60 ft. (rat form only)");
                    return;
                case Darkvision.The80Ft:
                    serializer.Serialize(writer, "80 ft.");
                    return;
                case Darkvision.The90Ft:
                    serializer.Serialize(writer, "90 ft.");
                    return;
            }
            throw new Exception("Cannot marshal type Darkvision");
        }

        public static readonly DarkvisionConverter Singleton = new DarkvisionConverter();
    }

    internal class ProficiencyNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ProficiencyName) || t == typeof(ProficiencyName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Saving Throw: CHA":
                    return ProficiencyName.SavingThrowCha;
                case "Saving Throw: CON":
                    return ProficiencyName.SavingThrowCon;
                case "Saving Throw: DEX":
                    return ProficiencyName.SavingThrowDex;
                case "Saving Throw: INT":
                    return ProficiencyName.SavingThrowInt;
                case "Saving Throw: STR":
                    return ProficiencyName.SavingThrowStr;
                case "Saving Throw: WIS":
                    return ProficiencyName.SavingThrowWis;
                case "Skill: Acrobatics":
                    return ProficiencyName.SkillAcrobatics;
                case "Skill: Arcana":
                    return ProficiencyName.SkillArcana;
                case "Skill: Athletics":
                    return ProficiencyName.SkillAthletics;
                case "Skill: Deception":
                    return ProficiencyName.SkillDeception;
                case "Skill: History":
                    return ProficiencyName.SkillHistory;
                case "Skill: Insight":
                    return ProficiencyName.SkillInsight;
                case "Skill: Intimidation":
                    return ProficiencyName.SkillIntimidation;
                case "Skill: Investigation":
                    return ProficiencyName.SkillInvestigation;
                case "Skill: Medicine":
                    return ProficiencyName.SkillMedicine;
                case "Skill: Nature":
                    return ProficiencyName.SkillNature;
                case "Skill: Perception":
                    return ProficiencyName.SkillPerception;
                case "Skill: Performance":
                    return ProficiencyName.SkillPerformance;
                case "Skill: Persuasion":
                    return ProficiencyName.SkillPersuasion;
                case "Skill: Religion":
                    return ProficiencyName.SkillReligion;
                case "Skill: Stealth":
                    return ProficiencyName.SkillStealth;
                case "Skill: Survival":
                    return ProficiencyName.SkillSurvival;
            }
            throw new Exception("Cannot unmarshal type ProficiencyName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ProficiencyName)untypedValue;
            switch (value)
            {
                case ProficiencyName.SavingThrowCha:
                    serializer.Serialize(writer, "Saving Throw: CHA");
                    return;
                case ProficiencyName.SavingThrowCon:
                    serializer.Serialize(writer, "Saving Throw: CON");
                    return;
                case ProficiencyName.SavingThrowDex:
                    serializer.Serialize(writer, "Saving Throw: DEX");
                    return;
                case ProficiencyName.SavingThrowInt:
                    serializer.Serialize(writer, "Saving Throw: INT");
                    return;
                case ProficiencyName.SavingThrowStr:
                    serializer.Serialize(writer, "Saving Throw: STR");
                    return;
                case ProficiencyName.SavingThrowWis:
                    serializer.Serialize(writer, "Saving Throw: WIS");
                    return;
                case ProficiencyName.SkillAcrobatics:
                    serializer.Serialize(writer, "Skill: Acrobatics");
                    return;
                case ProficiencyName.SkillArcana:
                    serializer.Serialize(writer, "Skill: Arcana");
                    return;
                case ProficiencyName.SkillAthletics:
                    serializer.Serialize(writer, "Skill: Athletics");
                    return;
                case ProficiencyName.SkillDeception:
                    serializer.Serialize(writer, "Skill: Deception");
                    return;
                case ProficiencyName.SkillHistory:
                    serializer.Serialize(writer, "Skill: History");
                    return;
                case ProficiencyName.SkillInsight:
                    serializer.Serialize(writer, "Skill: Insight");
                    return;
                case ProficiencyName.SkillIntimidation:
                    serializer.Serialize(writer, "Skill: Intimidation");
                    return;
                case ProficiencyName.SkillInvestigation:
                    serializer.Serialize(writer, "Skill: Investigation");
                    return;
                case ProficiencyName.SkillMedicine:
                    serializer.Serialize(writer, "Skill: Medicine");
                    return;
                case ProficiencyName.SkillNature:
                    serializer.Serialize(writer, "Skill: Nature");
                    return;
                case ProficiencyName.SkillPerception:
                    serializer.Serialize(writer, "Skill: Perception");
                    return;
                case ProficiencyName.SkillPerformance:
                    serializer.Serialize(writer, "Skill: Performance");
                    return;
                case ProficiencyName.SkillPersuasion:
                    serializer.Serialize(writer, "Skill: Persuasion");
                    return;
                case ProficiencyName.SkillReligion:
                    serializer.Serialize(writer, "Skill: Religion");
                    return;
                case ProficiencyName.SkillStealth:
                    serializer.Serialize(writer, "Skill: Stealth");
                    return;
                case ProficiencyName.SkillSurvival:
                    serializer.Serialize(writer, "Skill: Survival");
                    return;
            }
            throw new Exception("Cannot marshal type ProficiencyName");
        }

        public static readonly ProficiencyNameConverter Singleton = new ProficiencyNameConverter();
    }

    internal class RefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Ref) || t == typeof(Ref?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "proficiencies/100":
                    return Ref.Proficiencies100;
                case "proficiencies/101":
                    return Ref.Proficiencies101;
                case "proficiencies/102":
                    return Ref.Proficiencies102;
                case "proficiencies/103":
                    return Ref.Proficiencies103;
                case "proficiencies/104":
                    return Ref.Proficiencies104;
                case "proficiencies/105":
                    return Ref.Proficiencies105;
                case "proficiencies/107":
                    return Ref.Proficiencies107;
                case "proficiencies/108":
                    return Ref.Proficiencies108;
                case "proficiencies/109":
                    return Ref.Proficiencies109;
                case "proficiencies/110":
                    return Ref.Proficiencies110;
                case "proficiencies/111":
                    return Ref.Proficiencies111;
                case "proficiencies/112":
                    return Ref.Proficiencies112;
                case "proficiencies/113":
                    return Ref.Proficiencies113;
                case "proficiencies/114":
                    return Ref.Proficiencies114;
                case "proficiencies/115":
                    return Ref.Proficiencies115;
                case "proficiencies/116":
                    return Ref.Proficiencies116;
                case "proficiencies/117":
                    return Ref.Proficiencies117;
                case "proficiencies/118":
                    return Ref.Proficiencies118;
                case "proficiencies/119":
                    return Ref.Proficiencies119;
                case "proficiencies/121":
                    return Ref.Proficiencies121;
                case "proficiencies/122":
                    return Ref.Proficiencies122;
                case "proficiencies/99":
                    return Ref.Proficiencies99;
            }
            throw new Exception("Cannot unmarshal type Ref");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Ref)untypedValue;
            switch (value)
            {
                case Ref.Proficiencies100:
                    serializer.Serialize(writer, "proficiencies/100");
                    return;
                case Ref.Proficiencies101:
                    serializer.Serialize(writer, "proficiencies/101");
                    return;
                case Ref.Proficiencies102:
                    serializer.Serialize(writer, "proficiencies/102");
                    return;
                case Ref.Proficiencies103:
                    serializer.Serialize(writer, "proficiencies/103");
                    return;
                case Ref.Proficiencies104:
                    serializer.Serialize(writer, "proficiencies/104");
                    return;
                case Ref.Proficiencies105:
                    serializer.Serialize(writer, "proficiencies/105");
                    return;
                case Ref.Proficiencies107:
                    serializer.Serialize(writer, "proficiencies/107");
                    return;
                case Ref.Proficiencies108:
                    serializer.Serialize(writer, "proficiencies/108");
                    return;
                case Ref.Proficiencies109:
                    serializer.Serialize(writer, "proficiencies/109");
                    return;
                case Ref.Proficiencies110:
                    serializer.Serialize(writer, "proficiencies/110");
                    return;
                case Ref.Proficiencies111:
                    serializer.Serialize(writer, "proficiencies/111");
                    return;
                case Ref.Proficiencies112:
                    serializer.Serialize(writer, "proficiencies/112");
                    return;
                case Ref.Proficiencies113:
                    serializer.Serialize(writer, "proficiencies/113");
                    return;
                case Ref.Proficiencies114:
                    serializer.Serialize(writer, "proficiencies/114");
                    return;
                case Ref.Proficiencies115:
                    serializer.Serialize(writer, "proficiencies/115");
                    return;
                case Ref.Proficiencies116:
                    serializer.Serialize(writer, "proficiencies/116");
                    return;
                case Ref.Proficiencies117:
                    serializer.Serialize(writer, "proficiencies/117");
                    return;
                case Ref.Proficiencies118:
                    serializer.Serialize(writer, "proficiencies/118");
                    return;
                case Ref.Proficiencies119:
                    serializer.Serialize(writer, "proficiencies/119");
                    return;
                case Ref.Proficiencies121:
                    serializer.Serialize(writer, "proficiencies/121");
                    return;
                case Ref.Proficiencies122:
                    serializer.Serialize(writer, "proficiencies/122");
                    return;
                case Ref.Proficiencies99:
                    serializer.Serialize(writer, "proficiencies/99");
                    return;
            }
            throw new Exception("Cannot marshal type Ref");
        }

        public static readonly RefConverter Singleton = new RefConverter();
    }

    internal class SizeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Size) || t == typeof(Size?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Gargantuan":
                    return Size.Gargantuan;
                case "Huge":
                    return Size.Huge;
                case "Large":
                    return Size.Large;
                case "Medium":
                    return Size.Medium;
                case "Small":
                    return Size.Small;
                case "Tiny":
                    return Size.Tiny;
            }
            throw new Exception("Cannot unmarshal type Size");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Size)untypedValue;
            switch (value)
            {
                case Size.Gargantuan:
                    serializer.Serialize(writer, "Gargantuan");
                    return;
                case Size.Huge:
                    serializer.Serialize(writer, "Huge");
                    return;
                case Size.Large:
                    serializer.Serialize(writer, "Large");
                    return;
                case Size.Medium:
                    serializer.Serialize(writer, "Medium");
                    return;
                case Size.Small:
                    serializer.Serialize(writer, "Small");
                    return;
                case Size.Tiny:
                    serializer.Serialize(writer, "Tiny");
                    return;
            }
            throw new Exception("Cannot marshal type Size");
        }

        public static readonly SizeConverter Singleton = new SizeConverter();
    }

    internal class BurrowConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Burrow) || t == typeof(Burrow?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "0 ft.":
                    return Burrow.The0Ft;
                case "10 ft.":
                    return Burrow.The10Ft;
                case "15 ft.":
                    return Burrow.The15Ft;
                case "20 ft.":
                    return Burrow.The20Ft;
                case "25 ft.":
                    return Burrow.The25Ft;
                case "30 ft.":
                    return Burrow.The30Ft;
                case "40 ft.":
                    return Burrow.The40Ft;
                case "5 ft.":
                    return Burrow.The5Ft;
                case "50 ft.":
                    return Burrow.The50Ft;
                case "60 ft.":
                    return Burrow.The60Ft;
                case "90 ft.":
                    return Burrow.The90Ft;
            }
            throw new Exception("Cannot unmarshal type Burrow");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Burrow)untypedValue;
            switch (value)
            {
                case Burrow.The0Ft:
                    serializer.Serialize(writer, "0 ft.");
                    return;
                case Burrow.The10Ft:
                    serializer.Serialize(writer, "10 ft.");
                    return;
                case Burrow.The15Ft:
                    serializer.Serialize(writer, "15 ft.");
                    return;
                case Burrow.The20Ft:
                    serializer.Serialize(writer, "20 ft.");
                    return;
                case Burrow.The25Ft:
                    serializer.Serialize(writer, "25 ft.");
                    return;
                case Burrow.The30Ft:
                    serializer.Serialize(writer, "30 ft.");
                    return;
                case Burrow.The40Ft:
                    serializer.Serialize(writer, "40 ft.");
                    return;
                case Burrow.The5Ft:
                    serializer.Serialize(writer, "5 ft.");
                    return;
                case Burrow.The50Ft:
                    serializer.Serialize(writer, "50 ft.");
                    return;
                case Burrow.The60Ft:
                    serializer.Serialize(writer, "60 ft.");
                    return;
                case Burrow.The90Ft:
                    serializer.Serialize(writer, "90 ft.");
                    return;
            }
            throw new Exception("Cannot marshal type Burrow");
        }

        public static readonly BurrowConverter Singleton = new BurrowConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "aberration":
                    return TypeEnum.Aberration;
                case "beast":
                    return TypeEnum.Beast;
                case "celestial":
                    return TypeEnum.Celestial;
                case "construct":
                    return TypeEnum.Construct;
                case "dragon":
                    return TypeEnum.Dragon;
                case "elemental":
                    return TypeEnum.Elemental;
                case "fey":
                    return TypeEnum.Fey;
                case "fiend":
                    return TypeEnum.Fiend;
                case "giant":
                    return TypeEnum.Giant;
                case "humanoid":
                    return TypeEnum.Humanoid;
                case "monstrosity":
                    return TypeEnum.Monstrosity;
                case "ooze":
                    return TypeEnum.Ooze;
                case "plant":
                    return TypeEnum.Plant;
                case "swarm of Tiny beasts":
                    return TypeEnum.SwarmOfTinyBeasts;
                case "undead":
                    return TypeEnum.Undead;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.Aberration:
                    serializer.Serialize(writer, "aberration");
                    return;
                case TypeEnum.Beast:
                    serializer.Serialize(writer, "beast");
                    return;
                case TypeEnum.Celestial:
                    serializer.Serialize(writer, "celestial");
                    return;
                case TypeEnum.Construct:
                    serializer.Serialize(writer, "construct");
                    return;
                case TypeEnum.Dragon:
                    serializer.Serialize(writer, "dragon");
                    return;
                case TypeEnum.Elemental:
                    serializer.Serialize(writer, "elemental");
                    return;
                case TypeEnum.Fey:
                    serializer.Serialize(writer, "fey");
                    return;
                case TypeEnum.Fiend:
                    serializer.Serialize(writer, "fiend");
                    return;
                case TypeEnum.Giant:
                    serializer.Serialize(writer, "giant");
                    return;
                case TypeEnum.Humanoid:
                    serializer.Serialize(writer, "humanoid");
                    return;
                case TypeEnum.Monstrosity:
                    serializer.Serialize(writer, "monstrosity");
                    return;
                case TypeEnum.Ooze:
                    serializer.Serialize(writer, "ooze");
                    return;
                case TypeEnum.Plant:
                    serializer.Serialize(writer, "plant");
                    return;
                case TypeEnum.SwarmOfTinyBeasts:
                    serializer.Serialize(writer, "swarm of Tiny beasts");
                    return;
                case TypeEnum.Undead:
                    serializer.Serialize(writer, "undead");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
